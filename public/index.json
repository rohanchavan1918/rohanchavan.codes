
[{"content":"","date":"9 June 2024","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"9 June 2024","externalUrl":null,"permalink":"/posts/projects/","section":"","summary":"","title":"","type":"posts"},{"content":"\rGo Randomify #\rGo Randomify is a lightweight command-line tool written in Go that allows you to generate randomized data within JSON templates. With Go Randomify, you can easily create dynamic JSON files for testing, prototyping,automations and more. Features #\rTemplate Filling: Easily populate JSON templates with randomized data. Customization: Easily customize the type and format of randomized data. Output format: Add output to Json files or pipe it to another tool Current Support: int, char,uuid. Installation #\rTo install Go Randomify, you can use go get:\ngo get github.com/rohanchavan1918/gorandomify Alternatively, you can clone the repository and build from source:\ngit clone https://github.com/rohanchavan1918/gorandomify.git cd gorandomify go build Easiest way is to simply download the binary from the releases page.\nUsage #\rGo Randomify provides a command-line interface for generating randomized JSON files. Here\u0026rsquo;s how to use it:\ngorandomify -t \u0026lt;template-file\u0026gt; -o \u0026lt;output-file: optional\u0026gt; -t, --template: Specify the path to the JSON template file.\n-o, --output: Specify the path to the output JSON file (optional), if not passed prints JSON to stdout.\nFor more options and examples, please refer to the documentation.\nConfiguration / Template #\rPlaceholders #\rType Description $UUID Inserts a UUID $INT Insert a random int (max 10000) $INT(MIN:MAX) Insert a random int between a lower and upper limit (limit of 10000 is not applied here) $CHAR(LIMIT) Add random characters upto passed LIMIT Examples #\rYou can customize the type and format of randomized data using a configuration file. Here\u0026rsquo;s an example configuration file:\n{ \u0026#34;uuid\u0026#34;: \u0026#34;$UUID\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;, \u0026#34;request_id\u0026#34;: \u0026#34;$UUID\u0026#34;, \u0026#34;some_int\u0026#34;: \u0026#34;$INT(100:200)\u0026#34;, \u0026#34;rand_int\u0026#34;: \u0026#34;$INT\u0026#34;, \u0026#34;rand_char\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;lol\u0026#34;: \u0026#34;asd\u0026#34;, \u0026#34;foo\u0026#34;: \u0026#34;asad\u0026#34;, \u0026#34;aas\u0026#34;: \u0026#34;asd\u0026#34; } } Above template generates below json\n{ \u0026#34;data\u0026#34;: { \u0026#34;aas\u0026#34;: \u0026#34;asd\u0026#34;, \u0026#34;foo\u0026#34;: \u0026#34;asad\u0026#34;, \u0026#34;lol\u0026#34;: \u0026#34;asd\u0026#34; }, \u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;, \u0026#34;rand_char\u0026#34;: \u0026#34;jXEiPwYZ8rYYN8VEvlsW6f2E42HfYJma9EEEzgRCNO0V7IFxg6f1jg5arrEbPeop0xLKWjuGhnI8bcxfDJhWozl0IIDqcKwfrvZw\u0026#34;, \u0026#34;rand_int\u0026#34;: 540, \u0026#34;request_id\u0026#34;: \u0026#34;4afab242-7d54-48cd-8f6a-501fe936ce66\u0026#34;, \u0026#34;some_int\u0026#34;: 181, \u0026#34;uuid\u0026#34;: \u0026#34;3edea700-0cf1-46d6-8381-e137b4b3e65f\u0026#34; } Contributing #\rContributions are welcome! If you have any ideas, suggestions, or bug reports, please open an issue or submit a pull request.\nLicense #\rThis project is licensed under the MIT License - see the LICENSE file for details.\n","date":"9 June 2024","externalUrl":null,"permalink":"/posts/projects/gorandomify/","section":"","summary":"\u003ca href=\"https://github.com/rohanchavan1918/gorandomify\"   target=\"_blank\"\u003e\r\n    Go Randomify\u003c/a\u003e is a lightweight command-line tool written in Go that allows you to generate randomized data within JSON templates. With Go Randomify, you can easily create dynamic JSON files for testing, prototyping,automations and more.","title":"Gorandomify","type":"posts"},{"content":"Go | Python | Microservices | Infosec\nWelcome to my corner of the web! I\u0026rsquo;m a seasoned Senior Software Engineer with a strong focus on Golang, Python, and distributed computing/ microservices. Over the years, I\u0026rsquo;ve honed my skills to deliver impactful solutions across a diverse array of projects, ranging from Martech platforms to cutting-edge AI-driven image enhancement. My journey in software engineering spans nearly 4 years, during which I\u0026rsquo;ve become deeply proficient in Python and Golang, leveraging the AWS stack extensively to craft robust and scalable solutions. Whether it\u0026rsquo;s optimizing performance or fostering seamless teamwork, I thrive in challenging environments where innovation is the name of the game. Passionate about pushing tech boundaries, I thrive on teamwork and optimization challenges. Outside of my professional endeavors, you\u0026rsquo;ll often find me immersed in the vibrant world of development conferences and hackathons, where I relish the opportunity to exchange ideas and push the boundaries of what\u0026rsquo;s possible in technology.\nLet\u0026rsquo;s connect and explore endless possibilities together!\n","date":"9 June 2024","externalUrl":null,"permalink":"/","section":"Rohan Chavan","summary":"Go | Python | Microservices | Infosec","title":"Rohan Chavan","type":"page"},{"content":"","date":"9 June 2024","externalUrl":null,"permalink":"/posts/blogs/","section":"","summary":"","title":"","type":"posts"},{"content":"\rThe Frustration of Repetition : Automating JSON Randomization #\rWe\u0026rsquo;ve all been there: staring down a mountain of repetitive tasks that stifle our creativity and slow down development. During development or testing, we often need to randomize JSON input based on a specific template. For example, when testing a POST endpoint locally, you might need to repeatedly update a value in your Postman or event file to meet unique constraints or de-duplication logic. This process can be tedious and time-consuming. I found myself in this exact situation over the past few months while working intensively on a serverless project. Each request needed a unique ID, and every code change required updating the events.json file used by the AWS SAM CLI. It was incredibly frustrating! After failing to find a tool that could handle template-based JSON randomization, I decided to take matters into my own hands. Here\u0026rsquo;s how I did it.\nPlanning it out #\rI wanted a tool that would let me define a JSON template and update only a few keys with specific types of values and lengths. Additionally, it’s crucial that the data falls within user-defined constraints—such as a string being exactly 25 characters long or an integer being between 3000 and 4000. Also, the data can be nested which also needs to be adressed.\nFor instance, consider the JSON below. Every time, I need a unique request ID (a UUID), an age between 20 and 30, and an OTP that is a 4-digit integer.\nBy creating a template file with placeholders, I can automate this process:\n{ \u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;, \u0026#34;request_id\u0026#34;: \u0026#34;$UUID\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$INT(20:30)\u0026#34;, \u0026#34;product_price\u0026#34;: \u0026#34;$INT\u0026#34;, \u0026#34;rand_char\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;token\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;, \u0026#34;OTP\u0026#34;: \u0026#34;$INT(1000:9999)\u0026#34; } } This template makes it easy to generate randomized data that meets specific constraints, streamlining development and testing while reducing repetitive tasks.\nCode walkthrough ! #\rGithub Repo :\nhttps://github.com/rohanchavan1918/gorandomify\nThis Go code defines a command-line tool that accepts input and output file paths as flags. It first checks if a source template file is provided; if not, it looks for input data passed through system arguments. It reads the input data, unmarshals it into a map, and then copies the data for manipulation. After traversing and updating the copied data, it marshals it back into JSON format. If an output file path is specified, it writes the updated JSON to that file; otherwise, it prints it to the console. This tool efficiently processes JSON data, offering flexibility in input methods and output destinations.\nfunc main() { sourcePath := flag.String(\u0026#34;t\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Source of template file\u0026#34;) destinationPath := flag.String(\u0026#34;o\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Destination path\u0026#34;) flag.Parse() var passedFromSysArgs bool = false var inputData []byte if *sourcePath == \u0026#34;\u0026#34; { if len(os.Args) \u0026lt; 2 { colorize(ColorRed, \u0026#34;no input or template file passed\u0026#34;) os.Exit(1) } passedFromSysArgs = true } if passedFromSysArgs { inputData = []byte(os.Args[1]) } else { var err error inputData, err = os.ReadFile(*sourcePath) if err != nil { colorize(ColorRed, err.Error()) return } } var originalData map[string]interface{} if err := json.Unmarshal(inputData, \u0026amp;originalData); err != nil { colorize(ColorRed, err.Error()) return } copiedData := copyData(originalData) traverseAndUpdate(originalData, copiedData) updatedJSON, err := json.MarshalIndent(copiedData, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { colorize(ColorRed, \u0026#34;Error: \u0026#34;+err.Error()) return } if *destinationPath != \u0026#34;\u0026#34; { if err := writeToFile(*destinationPath, updatedJSON); err != nil { colorize(ColorRed, \u0026#34;Error: \u0026#34;+err.Error()) return } colorize(ColorGreen, \u0026#34;JSON generated successfully: \u0026#34;+*destinationPath) } else { fmt.Println(string(updatedJSON)) } } The traverseAndUpdate function recursively traverses through the JSON data, updating values as needed. For each key-value pair, it checks the type of the value. If the value is a nested map, it recursively calls traverseAndUpdate to handle it. If the value is a string, it invokes the parseAndUpdate function to update it based on certain conditions.\nThe parseAndUpdate function takes a key-value pair, along with the original and copied data maps. It identifies if an updater function is available for the value and, if so, attempts to update the value accordingly. If successful, it updates both the original and copied data maps. If an error occurs during updating, it prints a red-colored error message. These helper functions facilitate the main functionality of the tool by handling data traversal, file writing, and value updating.\nfunc traverseAndUpdate(data, copiedData map[string]interface{}) { for key, value := range data { switch v := value.(type) { case map[string]interface{}: traverseAndUpdate(v, copiedData[key].(map[string]interface{})) case string: parseAndUpdate(key, v, data, copiedData) } } } func writeToFile(filename string, data []byte) error { return ioutil.WriteFile(filename, data, 0644) } func parseAndUpdate(key, value string, data, copiedData map[string]interface{}) { if updater := getUpdater(value); updater != nil { if newVal, err := updater.Update(value); err == nil { data[key] = newVal copiedData[key] = newVal } else { colorize(ColorRed, \u0026#34;Error updating key: \u0026#34;+key+\u0026#34;, value: \u0026#34;+value+\u0026#34;, err: \u0026#34;+err.Error()) } } } The getUpdater function determines the appropriate updater for a given value string. It checks the prefix of the value string to identify the type of update required. If the value starts with \u0026ldquo;$UUID\u0026rdquo;, it returns the UUID updater; if it starts with \u0026ldquo;$INT\u0026rdquo;, it returns the integer updater; and if it starts with \u0026ldquo;$CHAR\u0026rdquo;, it returns the character updater. If none of these conditions match, indicating an unsupported type, it returns nil.\nThe Updater interface defines a method Update that takes a string value and returns an interface and an error. This interface is implemented by three updater structs: UUIDUpdater, IntUpdater, and CharUpdater, each responsible for generating a UUID, parsing an integer, or generating a random string, respectively.\nThese updaters are stored in a map named updaters, with keys corresponding to the supported types and values being instances of the updater structs. When getUpdater identifies the type of updater needed, it retrieves the corresponding updater from this map and returns it.\nOverall, getUpdater plays a crucial role in determining the appropriate updater method based on the value string, facilitating the dynamic updating of JSON data based on predefined rules and types.\nfunc getInt(value string) (int, error) { matches := regexp.MustCompile(`^\\$INT\\((\\d+):(\\d+)\\)$`).FindStringSubmatch(value) if len(matches) == 0 { return rand.Intn(10000), nil } lower, err1 := strconv.Atoi(matches[1]) upper, err2 := strconv.Atoi(matches[2]) if err1 != nil || err2 != nil || lower \u0026gt; upper { return 0, fmt.Errorf(\u0026#34;invalid INT range\u0026#34;) } return rand.Intn(upper-lower+1) + lower, nil } func randomString(value string) (string, error) { length := 10 if parts := strings.Split(value, \u0026#34;(\u0026#34;); len(parts) == 2 { if l, err := strconv.Atoi(strings.TrimSuffix(parts[1], \u0026#34;)\u0026#34;)); err == nil { length = l } } return getRandomStrNlen(length), nil } func getRandomStrNlen(n int) string { const charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; rand.Seed(time.Now().UnixNano()) result := make([]byte, n) for i := range result { result[i] = charset[rand.Intn(len(charset))] } return string(result) } The getInt function parses a provided string to either generate a random integer within a specified range or a random integer between 0 and 9999 if no range is specified, ensuring validity of the input range. Conversely, randomString creates a random string of characters with a default length of 10, or a length specified in the input, using getRandomStrNlen, which generates a random string of alphanumeric characters of a specified length. These functions collectively facilitate the dynamic generation of data for JSON updates, ensuring variability and accuracy in the generated output.\nAlmost there #\rrun-snapshot-creation : gorandomify -t .\\events\\snapshot_creation_event_template.json -o .\\events\\snapshot_creation_event.json sam build LambdaName sam local invoke LambdaName -e .\\events\\snapshot_creation_event.json Now that the code is ready, I\u0026rsquo;ve made it even more convenient to use by building the binary and adding it to my system\u0026rsquo;s path. Additionally, I\u0026rsquo;ve updated the Makefile of my project to seamlessly integrate our newly created tool. Now, whenever I run the command make run-snapshot-creation, it triggers a series of actions.\nFirstly, gorandomify references the template file located in \\events\\snapshot_creation_event_template.json, populates the placeholders, and generates the output file in the same directory named .\\events\\snapshot_creation_event.json.\nSubsequently, SAM invokes the lambda with the newly generated event. This streamlined process ensures effortless data generation and lambda invocation, enhancing the efficiency of my project workflow.\nmake run-snapshot-creation Summing it up #\rIn a nutshell, tackling the monotony of repetitive tasks in development and testing became a priority to boost productivity. Enter gorandomify, my brainchild, designed to automate JSON data generation for my serverless project. This handy tool eliminates manual data manipulation, letting me focus on the fun stuff. With gorandomify seamlessly integrated into my workflow, I\u0026rsquo;ve reclaimed precious time and energy, paving the way for smoother sailing in software development. Here\u0026rsquo;s to innovation and problem-solving, making our coding lives a little sweeter, one line of code at a time!\n","date":"9 June 2024","externalUrl":null,"permalink":"/posts/blogs/gorandomify/","section":"","summary":"There comes a time when you get so bored doing some daily boring and repeative tasks during coding, eventually get fedup enough that you spend the next weekend to do something about it.","title":"The Frustration of Repetition","type":"posts"},{"content":"\rloghawk #\rTL;DR - Code Breaks, Fix it Faster 🚀 #\rLogHawk: #\rA smart alert generation tool seamlessly connecting with your logging stack (ELK/EFK), proactively notifying your team of any issues 🤫 Efficiently utilize time and resources by avoiding manual RCA (Root Cause Analysis) Decrease the MTTR (Mean time to Repair) and incident response Designed for user-friendliness, resilience, and scalability 🤖 Problem statement #\rPresently, a significant amount of resources and time are consumed when a production issue arises, despite the potential for early identification through alerts. However, implementing alerts extensively can be cumbersome, and there is a risk that certain issues might go unnoticed in the error-handling process. Utilizing real-time log parsing to detect alerts within log lines offers a straightforward and cost-effective solution to address this challenge.\nFeatures #\rBlazing Fast Platform Independent (Windows/Linux/x64/x32/ARM) Easy Integration with existing logging workflow No third party dependency Very simplistic and easy to use Custom Integrations can be easily added. SuccessFully Benchmarked 896316 log lines in 15 Minutes i.e 3,417,542,400 in 24 hours For more info #\rhttps://docs.google.com/presentation/d/1LYzHKAAGoY2HtWrBKzpgAyIqNyPHMKeq0l4e0EO_alI/edit#slide=id.g264007f43b6_0_99\n","date":"30 March 2024","externalUrl":null,"permalink":"/posts/projects/loghawk/","section":"","summary":"Code Breaks, Fix it Faster with loghawk 🚀","title":"Loghawk","type":"posts"},{"content":"\r# ./hello-world #\rHey folks! Welcome to my tech blog, where we\u0026rsquo;re kicking things off with a warm \u0026ldquo;Hello World\u0026rdquo;! It\u0026rsquo;s not just a title; it\u0026rsquo;s an invitation to join me on an exciting journey through the world of engineering, innovation, and more.\nIn this post, we\u0026rsquo;re diving into my experiences with Python, Golang, infosec, hackathons, personal projects, microservices, and system designs. But this isn\u0026rsquo;t just a one-way street , feel free to hit me up and let\u0026rsquo;s get this conversation started!\nHere\u0026rsquo;s to new connections, shared knowledge, and plenty of \u0026ldquo;ooh,I didnt knew that (^_^)\u0026rdquo; moments along the way!\nCan\u0026rsquo;t wait to hear from you,\nRohan\n","date":"30 March 2024","externalUrl":null,"permalink":"/posts/blogs/hello-world/","section":"","summary":"A new beginning","title":"Hello World","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]