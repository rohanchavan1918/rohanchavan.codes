
[{"content":"","date":"11 August 2024","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"11 August 2024","externalUrl":null,"permalink":"/posts/blogs/","section":"","summary":"","title":"","type":"posts"},{"content":"When I was not able to find a good alternative to the Linux wc (word count) command for Windows, I decided to build my own version. Written in Go, this tool is not only a faithful port of the original wc but also platform-independent, meaning it works seamlessly on any operating system where Go is supported or you can simply cross compile stand alone binaries for different platforms.\nIn this blog, I\u0026rsquo;ll walk you through how I built this tool, explaining the design choices, the code structure, and how you can use it.\nProject structure #\r│ go.mod │ readme.md ├───bin │ wc_linux_x64 │ wc_win_x64.exe ├───cmd │ main.go └───internal ├───models │ models.go ├───utils │ utils.go └───wc counter.go The project is divided into four main components:\nMain Entry Point (cmd/main.go): Handles the command-line interface and parses user input. Models (internal/models/models.go): Defines the data structures used across the application. Utilities (internal/utils/utils.go): Contains helper functions for flag management and output formatting. Word Counter (internal/wc/counter.go): The core logic for processing input and counting words, lines, characters, and bytes. Lets Go #\rLets first start with writing our main function\nThe cmd/main.go file is where the program starts. Here, I used the flag package to handle command-line arguments, making it easy for users to specify what they want to count (lines, words, bytes, etc.).\ncmd/main.go\n--- SNIPPED --- func main() { var c, m, l, w bool var bytes, chars, lines, words bool flag.BoolVar(\u0026amp;c, \u0026#34;c\u0026#34;, false, \u0026#34;print the byte counts\u0026#34;) flag.BoolVar(\u0026amp;bytes, \u0026#34;bytes\u0026#34;, false, \u0026#34;print the byte counts\u0026#34;) flag.BoolVar(\u0026amp;m, \u0026#34;m\u0026#34;, false, \u0026#34;print the character counts\u0026#34;) flag.BoolVar(\u0026amp;chars, \u0026#34;chars\u0026#34;, false, \u0026#34;print the character counts\u0026#34;) flag.BoolVar(\u0026amp;l, \u0026#34;l\u0026#34;, false, \u0026#34;print the line counts\u0026#34;) flag.BoolVar(\u0026amp;lines, \u0026#34;lines\u0026#34;, false, \u0026#34;print the line counts\u0026#34;) flag.BoolVar(\u0026amp;w, \u0026#34;w\u0026#34;, false, \u0026#34;print the word counts\u0026#34;) flag.BoolVar(\u0026amp;words, \u0026#34;words\u0026#34;, false, \u0026#34;print the word counts\u0026#34;) flag.Parse() availableCommands := []string{\u0026#34;l\u0026#34;, \u0026#34;lines\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;words\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;bytes\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;chars\u0026#34;} usedFlags := utils.FlagUsed(availableCommands...) input := models.NewInput(usedFlags, flag.Args()) wc.Process(input, usedFlags) } You can notice that I have used a seperate flag for short command and long command. Packages like Cobra does it in more elegant way but i didnt wanted to use any packages for this tool.\nutils.FlagUsed is a helper function which returns what flags have been passed by the user in sys args.\nHeres how it looks\nfunc FlagUsed(s ...string) []string { usedFlags := []string{} for _, fn := range s { flag.Visit(func(f *flag.Flag) { if f.Name == fn { usedFlags = append(usedFlags, fn) return } }) } return usedFlags } Now that we have the flags passed by the user, lets define a struct which helps us represent data in a better way\ntype Input struct { Bytes bool Chars bool Lines bool Words bool Files []string } The input struct will hold boolean values for different kind of types for which we need the count, and the Files in which we need to count. However, if no flag is passed by user wc by default counts the bytes, chars, and new lines, so when we initialize the Input we need to check if the user had passed any flags or not, and accordigly initialize the Input struct. Lets create a method to the Input struct to handle it.\nfunc NewInput(usedFlags, files []string) Input { if len(usedFlags) == 0 { // Return Input with all as true return Input{true, true, true, true, files} } input := Input{} for _, fn := range usedFlags { if fn == \u0026#34;c\u0026#34; || fn == \u0026#34;bytes\u0026#34; { input.Bytes = true } if fn == \u0026#34;m\u0026#34; || fn == \u0026#34;chars\u0026#34; { input.Chars = true } if fn == \u0026#34;l\u0026#34; || fn == \u0026#34;lines\u0026#34; { input.Lines = true } if fn == \u0026#34;w\u0026#34; || fn == \u0026#34;words\u0026#34; { input.Words = true } } input.Files = files return input } We have what we need to count to process, our main function has a single entry points to process the input. It is defined in the\ninternal/wc/counter.go\nfunc Process(input models.Input, usedFlags []string) { // Check if the input is coming from files or stdIn if len(input.Files) \u0026gt; 0 { ProcessFiles(input, usedFlags) } else { ProcessStdin(input, usedFlags) } } wc can also accept input from the STDIN if no files are passed in the input, that is why we have two different functions in the Process. Lets have a deeper dive in ProcessFiles func\nfunc ProcessFiles(input models.Input, usedFlags []string) error { fileResults := []models.FileOp{} totalResult := models.Output{} for _, file := range input.Files { fileResult := models.FileOp{File: file} // wc does not give line count, but newLine count thus we need to initialize Lines to -1 op := models.Output{Lines: -1} f, err := os.OpenFile(file, os.O_RDONLY, os.ModePerm) if err != nil { fmt.Println(\u0026#34;Failed to process file \u0026#34;, file) fmt.Println(\u0026#34;Error \u0026#34;, err.Error()) continue } defer f.Close() scanner := bufio.NewScanner(f) for scanner.Scan() { if err := ProcessLine(input, scanner.Bytes(), \u0026amp;op); err == nil { op.AddCount(\u0026#34;lines\u0026#34;, 1) } } if err := scanner.Err(); err != nil { return err } fileResult.Output = op fileResults = append(fileResults, fileResult) totalResult.AddCount(\u0026#34;bytes\u0026#34;, op.Bytes) totalResult.AddCount(\u0026#34;chars\u0026#34;, op.Chars) totalResult.AddCount(\u0026#34;lines\u0026#34;, op.Lines) totalResult.AddCount(\u0026#34;words\u0026#34;, op.Words) } for _, op := range fileResults { utils.PrintResult(usedFlags, op.Output, op.File) } if len(fileResults) \u0026gt; 1 { utils.PrintResult(usedFlags, totalResult, \u0026#34;total\u0026#34;) } return nil } The ProcessFiles function is designed to handle word count operations for multiple files. It begins by initializing an empty slice to store results for each file and an Output structure to accumulate the total counts. The function then iterates over each file provided in the input, opening the file in read-only mode. A bufio.Scanner is used to read the file line by line, and for each line, the ProcessLine function updates the counts for lines, words, characters, and bytes. Since the tool counts newline characters instead of lines, the line count is initialized to -1. If any error occurs while reading a file, the function continues with the next file. After processing each file, the individual results are stored, and the totals are updated. Finally, the results for each file are printed, and if multiple files were processed, the combined totals are also displayed. The function returns nil if no errors occur during the scanning process.\nfunc ProcessStdin(input models.Input, usedFlags []string) error { scanner := bufio.NewScanner(os.Stdin) output := models.Output{Lines: -1} for scanner.Scan() { if err := ProcessLine(input, scanner.Bytes(), \u0026amp;output); err == nil { output.AddCount(\u0026#34;lines\u0026#34;, 1) } } if err := scanner.Err(); err != nil { return err } utils.PrintResult(usedFlags, output, \u0026#34;\u0026#34;) return nil } The ProcessStdin function is designed to handle word count operations when input is provided via standard input (stdin), making it useful in situations where the tool is used in a pipeline or interactively. The function begins by creating a bufio.Scanner to read the input line by line from stdin. It also initializes an Output structure with the line count set to -1 to account for the newline-based line counting. As each line is scanned, the ProcessLine function is called to update the counts for lines, words, characters, and bytes. The line count is incremented after each line is successfully processed. Once the scanning is complete, the function checks for any errors that might have occurred during the scanning process. If no errors are found, it prints the results using the PrintResult function, displaying the counts based on the flags used. The function returns any scanning errors it encounters, or nil if the operation completes successfully.\nBelow is a quick look for Output, this also includes a AddCount method, but we will look into it later on. The FileOp struct embeds the Output struct and also includes a File string field which will hold the file name.\ntype Output struct { Bytes int Chars int Lines int Words int } type FileOp struct { File string Output Output } If you have observed carefully ProcessLine is the function which adds the counts line by line in both the file mode as well as the stdin. lets have a look into it.\nfunc ProcessLine(ip models.Input, line []byte, op *models.Output) error { if ip.Bytes { op.AddCount(\u0026#34;bytes\u0026#34;, len(line)) } if ip.Chars { op.AddCount(\u0026#34;chars\u0026#34;, utf8.RuneCount(line)) } if ip.Words { // Calculate words wSlc := string(line) words := 0 wordStarted := false for _, s := range wSlc { if string(s) != \u0026#34; \u0026#34; \u0026amp;\u0026amp; !wordStarted { wordStarted = true words++ } else if string(s) == \u0026#34; \u0026#34; \u0026amp;\u0026amp; wordStarted { wordStarted = false } } op.AddCount(\u0026#34;words\u0026#34;, words) } return nil } AddCount implementation is fairly simple, it increments the count of a particular field by the passed amount n\nfunc (o *Output) AddCount(field string, n int) { switch field { case \u0026#34;bytes\u0026#34;: o.Bytes += n return case \u0026#34;chars\u0026#34;: o.Chars += n return case \u0026#34;lines\u0026#34;: o.Lines += n return case \u0026#34;words\u0026#34;: o.Words += n return } } Great! till now we have managed to get the counts, but we need to make sure that the way we print/display our data is similiar to wc.\nutils/utils.go\nfunc PrintFilesResult(flags []string, o []models.FileOp) { for _, fn := range o { PrintResult(flags, fn.Output, fn.File) } } PrintFilesResult will iterate the files and call the PrintResult function\nfunc PrintResult(flags []string, o models.Output, fn string) { if len(flags) == 0 { fmt.Printf(\u0026#34;%d %d %d %s\\n\u0026#34;, o.Lines, o.Words, o.Bytes, fn) return } op := \u0026#34;\u0026#34; for _, f := range flags { if f == \u0026#34;l\u0026#34; || f == \u0026#34;lines\u0026#34; { op = op + fmt.Sprintf(\u0026#34;%d \u0026#34;, o.Lines) } if f == \u0026#34;w\u0026#34; || f == \u0026#34;words\u0026#34; { op = op + fmt.Sprintf(\u0026#34;%d \u0026#34;, o.Words) } if f == \u0026#34;c\u0026#34; || f == \u0026#34;bytes\u0026#34; { op = op + fmt.Sprintf(\u0026#34;%d \u0026#34;, o.Bytes) } if f == \u0026#34;m\u0026#34; || f == \u0026#34;chars\u0026#34; { op = op + fmt.Sprintf(\u0026#34;%d \u0026#34;, o.Chars) } } op = op + fn fmt.Println(op) } If the user havent passed any flags, the default output needs to be printed. we then check for the flags which have been passed and create the final output string.\nRunning the code #\rLets build the binary\ngo build -o ./bin/wc_win_x64 cmd/main.go Below is the content of file.txt\nhello world lets go bro we can also run it like\nPS C:\\Users\\rohan\\Desktop\\personal\\wc\u0026gt; go run .\\cmd\\main.go file.txt 1 5 22 file.txt PS C:\\Users\\rohan\\Desktop\\personal\\wc\u0026gt; As expected, when we dont pass any flags the default output is printing new lines, number of chars and bytes\nLets pass some flags and test it\nPS C:\\Users\\rohan\\Desktop\\personal\\wc\u0026gt; go run .\\cmd\\main.go -l -w file.txt 1 5 file.txt PS C:\\Users\\rohan\\Desktop\\personal\\wc\u0026gt; Room for improvement #\rThis is a basic implementation, and theres still room for improvement. we could implement go routines etc to make it even faster and would give significant performance benefits when processing large files.\nGive me the code #\rIf you have followed along till here, you definitely want to have a look at the code. Below is the github repo for this proeject.\nhttps://github.com/rohanchavan1918/wc #\rThanks and regards!\nRohan\n","date":"11 August 2024","externalUrl":null,"permalink":"/posts/blogs/wc/","section":"","summary":"When I was not able to find a good alternative to the Linux wc (word count) command for Windows, I decided to build my own version.","title":"Building wc (word count) in Go","type":"posts"},{"content":"Go | Python | Microservices | Infosec\nWelcome to my corner of the web! I\u0026rsquo;m a seasoned Senior Software Engineer with a strong focus on Golang, Python, and distributed computing/ microservices. Over the years, I\u0026rsquo;ve honed my skills to deliver impactful solutions across a diverse array of projects, ranging from Martech platforms to cutting-edge AI-driven image enhancement. My journey in software engineering spans nearly 4 years, during which I\u0026rsquo;ve become deeply proficient in Python and Golang, leveraging the AWS stack extensively to craft robust and scalable solutions. Whether it\u0026rsquo;s optimizing performance or fostering seamless teamwork, I thrive in challenging environments where innovation is the name of the game. Passionate about pushing tech boundaries, I thrive on teamwork and optimization challenges. Outside of my professional endeavors, you\u0026rsquo;ll often find me immersed in the vibrant world of development conferences and hackathons, where I relish the opportunity to exchange ideas and push the boundaries of what\u0026rsquo;s possible in technology.\nLet\u0026rsquo;s connect and explore endless possibilities together!\n","date":"11 August 2024","externalUrl":null,"permalink":"/","section":"Rohan Chavan","summary":"Go | Python | Microservices | Infosec","title":"Rohan Chavan","type":"page"},{"content":"","date":"9 June 2024","externalUrl":null,"permalink":"/posts/projects/","section":"","summary":"","title":"","type":"posts"},{"content":"\rGo Randomify #\rGo Randomify is a lightweight command-line tool written in Go that allows you to generate randomized data within JSON templates. With Go Randomify, you can easily create dynamic JSON files for testing, prototyping,automations and more.\rFeatures #\rTemplate Filling: Easily populate JSON templates with randomized data. Customization: Easily customize the type and format of randomized data. Output format: Add output to Json files or pipe it to another tool Current Support: int, char,uuid. Installation #\rTo install Go Randomify, you can use go get:\ngo get github.com/rohanchavan1918/gorandomify Alternatively, you can clone the repository and build from source:\ngit clone https://github.com/rohanchavan1918/gorandomify.git cd gorandomify go build Easiest way is to simply download the binary from the releases page.\nUsage #\rGo Randomify provides a command-line interface for generating randomized JSON files. Here\u0026rsquo;s how to use it:\ngorandomify -t \u0026lt;template-file\u0026gt; -o \u0026lt;output-file: optional\u0026gt; -t, --template: Specify the path to the JSON template file.\n-o, --output: Specify the path to the output JSON file (optional), if not passed prints JSON to stdout.\nFor more options and examples, please refer to the documentation.\nConfiguration / Template #\rPlaceholders #\rType Description $UUID Inserts a UUID $INT Insert a random int (max 10000) $INT(MIN:MAX) Insert a random int between a lower and upper limit (limit of 10000 is not applied here) $CHAR(LIMIT) Add random characters upto passed LIMIT Examples #\rYou can customize the type and format of randomized data using a configuration file. Here\u0026rsquo;s an example configuration file:\n{\r\u0026#34;uuid\u0026#34;: \u0026#34;$UUID\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;,\r\u0026#34;request_id\u0026#34;: \u0026#34;$UUID\u0026#34;,\r\u0026#34;some_int\u0026#34;: \u0026#34;$INT(100:200)\u0026#34;,\r\u0026#34;rand_int\u0026#34;: \u0026#34;$INT\u0026#34;,\r\u0026#34;rand_char\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;,\r\u0026#34;data\u0026#34;: {\r\u0026#34;lol\u0026#34;: \u0026#34;asd\u0026#34;,\r\u0026#34;foo\u0026#34;: \u0026#34;asad\u0026#34;,\r\u0026#34;aas\u0026#34;: \u0026#34;asd\u0026#34;\r}\r} Above template generates below json\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;aas\u0026#34;: \u0026#34;asd\u0026#34;,\r\u0026#34;foo\u0026#34;: \u0026#34;asad\u0026#34;,\r\u0026#34;lol\u0026#34;: \u0026#34;asd\u0026#34;\r},\r\u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;,\r\u0026#34;rand_char\u0026#34;: \u0026#34;jXEiPwYZ8rYYN8VEvlsW6f2E42HfYJma9EEEzgRCNO0V7IFxg6f1jg5arrEbPeop0xLKWjuGhnI8bcxfDJhWozl0IIDqcKwfrvZw\u0026#34;,\r\u0026#34;rand_int\u0026#34;: 540,\r\u0026#34;request_id\u0026#34;: \u0026#34;4afab242-7d54-48cd-8f6a-501fe936ce66\u0026#34;,\r\u0026#34;some_int\u0026#34;: 181,\r\u0026#34;uuid\u0026#34;: \u0026#34;3edea700-0cf1-46d6-8381-e137b4b3e65f\u0026#34;\r} Contributing #\rContributions are welcome! If you have any ideas, suggestions, or bug reports, please open an issue or submit a pull request.\nLicense #\rThis project is licensed under the MIT License - see the LICENSE file for details.\n","date":"9 June 2024","externalUrl":null,"permalink":"/posts/projects/gorandomify/","section":"","summary":"\u003ccode\u003egorandomify\u003c/code\u003e is a lightweight command-line tool written in Go that allows you to generate randomized data within JSON templates. With Go Randomify, you can easily create dynamic JSON files for testing, prototyping,automations and more.","title":"Gorandomify","type":"posts"},{"content":"\rThe Frustration of Repetition : Automating JSON Randomization #\rWe\u0026rsquo;ve all been there: staring down a mountain of repetitive tasks that stifle our creativity and slow down development. During development or testing, we often need to randomize JSON input based on a specific template. For example, when testing a POST endpoint locally, you might need to repeatedly update a value in your Postman or event file to meet unique constraints or de-duplication logic. This process can be tedious and time-consuming. I found myself in this exact situation over the past few months while working intensively on a serverless project. Each request needed a unique ID, and every code change required updating the events.json file used by the AWS SAM CLI. It was incredibly frustrating! After failing to find a tool that could handle template-based JSON randomization, I decided to take matters into my own hands. Here\u0026rsquo;s how I did it.\nPlanning it out #\rI wanted a tool that would let me define a JSON template and update only a few keys with specific types of values and lengths. Additionally, it’s crucial that the data falls within user-defined constraints—such as a string being exactly 25 characters long or an integer being between 3000 and 4000. Also, the data can be nested which also needs to be adressed.\nFor instance, consider the JSON below. Every time, I need a unique request ID (a UUID), an age between 20 and 30, and an OTP that is a 4-digit integer.\nBy creating a template file with placeholders, I can automate this process:\n{ \u0026#34;name\u0026#34;: \u0026#34;rohan\u0026#34;, \u0026#34;request_id\u0026#34;: \u0026#34;$UUID\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$INT(20:30)\u0026#34;, \u0026#34;product_price\u0026#34;: \u0026#34;$INT\u0026#34;, \u0026#34;rand_char\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;token\u0026#34;: \u0026#34;$CHAR(100)\u0026#34;, \u0026#34;OTP\u0026#34;: \u0026#34;$INT(1000:9999)\u0026#34; } } This template makes it easy to generate randomized data that meets specific constraints, streamlining development and testing while reducing repetitive tasks.\nCode walkthrough ! #\rGithub Repo :\nhttps://github.com/rohanchavan1918/gorandomify\nThis Go code defines a command-line tool that accepts input and output file paths as flags. It first checks if a source template file is provided; if not, it looks for input data passed through system arguments. It reads the input data, unmarshals it into a map, and then copies the data for manipulation. After traversing and updating the copied data, it marshals it back into JSON format. If an output file path is specified, it writes the updated JSON to that file; otherwise, it prints it to the console. This tool efficiently processes JSON data, offering flexibility in input methods and output destinations.\nfunc main() { sourcePath := flag.String(\u0026#34;t\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Source of template file\u0026#34;) destinationPath := flag.String(\u0026#34;o\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Destination path\u0026#34;) flag.Parse() var passedFromSysArgs bool = false var inputData []byte if *sourcePath == \u0026#34;\u0026#34; { if len(os.Args) \u0026lt; 2 { colorize(ColorRed, \u0026#34;no input or template file passed\u0026#34;) os.Exit(1) } passedFromSysArgs = true } if passedFromSysArgs { inputData = []byte(os.Args[1]) } else { var err error inputData, err = os.ReadFile(*sourcePath) if err != nil { colorize(ColorRed, err.Error()) return } } var originalData map[string]interface{} if err := json.Unmarshal(inputData, \u0026amp;originalData); err != nil { colorize(ColorRed, err.Error()) return } copiedData := copyData(originalData) traverseAndUpdate(originalData, copiedData) updatedJSON, err := json.MarshalIndent(copiedData, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { colorize(ColorRed, \u0026#34;Error: \u0026#34;+err.Error()) return } if *destinationPath != \u0026#34;\u0026#34; { if err := writeToFile(*destinationPath, updatedJSON); err != nil { colorize(ColorRed, \u0026#34;Error: \u0026#34;+err.Error()) return } colorize(ColorGreen, \u0026#34;JSON generated successfully: \u0026#34;+*destinationPath) } else { fmt.Println(string(updatedJSON)) } } The traverseAndUpdate function recursively traverses through the JSON data, updating values as needed. For each key-value pair, it checks the type of the value. If the value is a nested map, it recursively calls traverseAndUpdate to handle it. If the value is a string, it invokes the parseAndUpdate function to update it based on certain conditions.\nThe parseAndUpdate function takes a key-value pair, along with the original and copied data maps. It identifies if an updater function is available for the value and, if so, attempts to update the value accordingly. If successful, it updates both the original and copied data maps. If an error occurs during updating, it prints a red-colored error message. These helper functions facilitate the main functionality of the tool by handling data traversal, file writing, and value updating.\nfunc traverseAndUpdate(data, copiedData map[string]interface{}) { for key, value := range data { switch v := value.(type) { case map[string]interface{}: traverseAndUpdate(v, copiedData[key].(map[string]interface{})) case string: parseAndUpdate(key, v, data, copiedData) } } } func writeToFile(filename string, data []byte) error { return ioutil.WriteFile(filename, data, 0644) } func parseAndUpdate(key, value string, data, copiedData map[string]interface{}) { if updater := getUpdater(value); updater != nil { if newVal, err := updater.Update(value); err == nil { data[key] = newVal copiedData[key] = newVal } else { colorize(ColorRed, \u0026#34;Error updating key: \u0026#34;+key+\u0026#34;, value: \u0026#34;+value+\u0026#34;, err: \u0026#34;+err.Error()) } } } The getUpdater function determines the appropriate updater for a given value string. It checks the prefix of the value string to identify the type of update required. If the value starts with \u0026ldquo;$UUID\u0026rdquo;, it returns the UUID updater; if it starts with \u0026ldquo;$INT\u0026rdquo;, it returns the integer updater; and if it starts with \u0026ldquo;$CHAR\u0026rdquo;, it returns the character updater. If none of these conditions match, indicating an unsupported type, it returns nil.\nThe Updater interface defines a method Update that takes a string value and returns an interface and an error. This interface is implemented by three updater structs: UUIDUpdater, IntUpdater, and CharUpdater, each responsible for generating a UUID, parsing an integer, or generating a random string, respectively.\nThese updaters are stored in a map named updaters, with keys corresponding to the supported types and values being instances of the updater structs. When getUpdater identifies the type of updater needed, it retrieves the corresponding updater from this map and returns it.\nOverall, getUpdater plays a crucial role in determining the appropriate updater method based on the value string, facilitating the dynamic updating of JSON data based on predefined rules and types.\nfunc getInt(value string) (int, error) { matches := regexp.MustCompile(`^\\$INT\\((\\d+):(\\d+)\\)$`).FindStringSubmatch(value) if len(matches) == 0 { return rand.Intn(10000), nil } lower, err1 := strconv.Atoi(matches[1]) upper, err2 := strconv.Atoi(matches[2]) if err1 != nil || err2 != nil || lower \u0026gt; upper { return 0, fmt.Errorf(\u0026#34;invalid INT range\u0026#34;) } return rand.Intn(upper-lower+1) + lower, nil } func randomString(value string) (string, error) { length := 10 if parts := strings.Split(value, \u0026#34;(\u0026#34;); len(parts) == 2 { if l, err := strconv.Atoi(strings.TrimSuffix(parts[1], \u0026#34;)\u0026#34;)); err == nil { length = l } } return getRandomStrNlen(length), nil } func getRandomStrNlen(n int) string { const charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; rand.Seed(time.Now().UnixNano()) result := make([]byte, n) for i := range result { result[i] = charset[rand.Intn(len(charset))] } return string(result) } The getInt function parses a provided string to either generate a random integer within a specified range or a random integer between 0 and 9999 if no range is specified, ensuring validity of the input range. Conversely, randomString creates a random string of characters with a default length of 10, or a length specified in the input, using getRandomStrNlen, which generates a random string of alphanumeric characters of a specified length. These functions collectively facilitate the dynamic generation of data for JSON updates, ensuring variability and accuracy in the generated output.\nAlmost there #\rrun-snapshot-creation : gorandomify -t .\\events\\snapshot_creation_event_template.json -o .\\events\\snapshot_creation_event.json sam build LambdaName sam local invoke LambdaName -e .\\events\\snapshot_creation_event.json Now that the code is ready, I\u0026rsquo;ve made it even more convenient to use by building the binary and adding it to my system\u0026rsquo;s path. Additionally, I\u0026rsquo;ve updated the Makefile of my project to seamlessly integrate our newly created tool. Now, whenever I run the command make run-snapshot-creation, it triggers a series of actions.\nFirstly, gorandomify references the template file located in \\events\\snapshot_creation_event_template.json, populates the placeholders, and generates the output file in the same directory named .\\events\\snapshot_creation_event.json.\nSubsequently, SAM invokes the lambda with the newly generated event. This streamlined process ensures effortless data generation and lambda invocation, enhancing the efficiency of my project workflow.\nmake run-snapshot-creation Summing it up #\rIn a nutshell, tackling the monotony of repetitive tasks in development and testing became a priority to boost productivity.This handy tool eliminates manual data manipulation, letting me focus on the fun stuff. With gorandomify seamlessly integrated into my workflow, I\u0026rsquo;ve reclaimed precious time and energy, paving the way for smoother sailing in software development. Here\u0026rsquo;s to innovation and problem-solving, making our coding lives a little sweeter, one line of code at a time!\n","date":"9 June 2024","externalUrl":null,"permalink":"/posts/blogs/gorandomify/","section":"","summary":"There comes a time when you get so bored doing some daily boring and repeative tasks during coding, eventually get fedup enough that you spend the next weekend to do something about it.","title":"The Frustration of Repetition","type":"posts"},{"content":"\rloghawk #\rTL;DR - Code Breaks, Fix it Faster 🚀 #\rLogHawk: #\rA smart alert generation tool seamlessly connecting with your logging stack (ELK/EFK), proactively notifying your team of any issues 🤫 Efficiently utilize time and resources by avoiding manual RCA (Root Cause Analysis) Decrease the MTTR (Mean time to Repair) and incident response Designed for user-friendliness, resilience, and scalability 🤖 Problem statement #\rPresently, a significant amount of resources and time are consumed when a production issue arises, despite the potential for early identification through alerts. However, implementing alerts extensively can be cumbersome, and there is a risk that certain issues might go unnoticed in the error-handling process. Utilizing real-time log parsing to detect alerts within log lines offers a straightforward and cost-effective solution to address this challenge.\nFeatures #\rBlazing Fast Platform Independent (Windows/Linux/x64/x32/ARM) Easy Integration with existing logging workflow No third party dependency Very simplistic and easy to use Custom Integrations can be easily added. SuccessFully Benchmarked 896316 log lines in 15 Minutes i.e 3,417,542,400 in 24 hours For more info #\rhttps://docs.google.com/presentation/d/1LYzHKAAGoY2HtWrBKzpgAyIqNyPHMKeq0l4e0EO_alI/edit#slide=id.g264007f43b6_0_99\n","date":"30 March 2024","externalUrl":null,"permalink":"/posts/projects/loghawk/","section":"","summary":"Code Breaks, Fix it Faster with loghawk 🚀","title":"Loghawk","type":"posts"},{"content":"\r# ./hello-world #\rHey folks! Welcome to my tech blog, where we\u0026rsquo;re kicking things off with a warm \u0026ldquo;Hello World\u0026rdquo;! It\u0026rsquo;s not just a title; it\u0026rsquo;s an invitation to join me on an exciting journey through the world of engineering, innovation, and more.\nIn this post, we\u0026rsquo;re diving into my experiences with Python, Golang, infosec, hackathons, personal projects, microservices, and system designs. But this isn\u0026rsquo;t just a one-way street , feel free to hit me up and let\u0026rsquo;s get this conversation started!\nHere\u0026rsquo;s to new connections, shared knowledge, and plenty of \u0026ldquo;ooh,I didnt knew that (^_^)\u0026rdquo; moments along the way!\nCan\u0026rsquo;t wait to hear from you,\nRohan\n","date":"30 March 2024","externalUrl":null,"permalink":"/posts/blogs/hello-world/","section":"","summary":"A new beginning","title":"Hello World","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]